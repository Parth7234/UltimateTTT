import random

# =======================================================
# BOT CODE (SYNCHRONIZED WITH THE GAME ENGINE)
#generated by chatgpt 3.0
# =======================================================

# Constants to match the engine's representation for clarity
EMPTY = 0
P1 = 1 # 'X'
P2 = 2 # 'O'
DRAW = 3

# --- 1. HELPER FUNCTIONS ---

def get_subgame(board, subgame_r, subgame_c):
    """Returns the 3x3 subgame as a 2D list."""
    return [board[subgame_r * 3 + r][subgame_c * 3 : subgame_c * 3 + 3] for r in range(3)]

def get_subgame_status(subgame):
    """
    Checks the status of a 3x3 subgame.
    Returns P1, P2 if there's a winner, DRAW if full, or EMPTY if ongoing.
    """
    # Check rows and columns
    for i in range(3):
        if subgame[i][0] == subgame[i][1] == subgame[i][2] and subgame[i][0] != EMPTY:
            return subgame[i][0]
        if subgame[0][i] == subgame[1][i] == subgame[2][i] and subgame[0][i] != EMPTY:
            return subgame[0][i]
    # Check diagonals
    if subgame[0][0] == subgame[1][1] == subgame[2][2] and subgame[0][0] != EMPTY:
        return subgame[0][0]
    if subgame[0][2] == subgame[1][1] == subgame[2][0] and subgame[1][1] != EMPTY:
        return subgame[1][1]
    
    # Check for fullness (draw)
    if all(cell != EMPTY for row in subgame for cell in row):
        return DRAW
        
    return EMPTY # Ongoing

def get_global_board_state(board):
    """Creates a 3x3 representation of the main board's status."""
    global_board = [[EMPTY for _ in range(3)] for _ in range(3)]
    for r in range(3):
        for c in range(3):
            subgame = get_subgame(board, r, c)
            global_board[r][c] = get_subgame_status(subgame)
    return global_board

# --- 2. MOVE GENERATION ---

def get_valid_moves(board, main_board_state, prev_move):
    """
    Returns a list of all legal (row, col) moves. This logic now mirrors
    the game engine's get_valid_moves() perfectly.
    """
    if prev_move is None:
        return [(r, c) for r in range(9) for c in range(9) if board[r][c] == EMPTY]

    target_r, target_c = prev_move[0] % 3, prev_move[1] % 3

    # If target subgame is won or drawn, player can move in any *other* unfinished subgame
    if main_board_state[target_r][target_c] != EMPTY:
        valid_moves = []
        for r_sub in range(3):
            for c_sub in range(3):
                if main_board_state[r_sub][c_sub] == EMPTY:
                    for r_local in range(3):
                        for c_local in range(3):
                            if board[r_sub * 3 + r_local][c_sub * 3 + c_local] == EMPTY:
                                valid_moves.append((r_sub * 3 + r_local, c_sub * 3 + c_local))
        return valid_moves
    
    # Otherwise, moves are restricted to the target subgame
    else:
        valid_moves = []
        base_r, base_c = target_r * 3, target_c * 3
        for r_local in range(3):
            for c_local in range(3):
                if board[base_r + r_local][base_c + c_local] == EMPTY:
                    valid_moves.append((base_r + r_local, base_c + c_local))
        return valid_moves

# --- 3. AI STRATEGY (EVALUATION AND MINIMAX) ---

def evaluate_board(board, global_board, player_id):
    """
    Heuristic function to score the board for the given player.
    """
    opponent_id = P2 if player_id == P1 else P1
    
    # Check for a global win/loss (highest priority)
    winner = get_subgame_status(global_board)
    if winner == player_id:
        return 10000
    if winner == opponent_id:
        return -10000
    if winner == DRAW:
        return 0

    # If no winner, score based on subgame control
    total_score = 0
    player_subgames = 0
    opponent_subgames = 0
    
    for r in range(3):
        for c in range(3):
            if global_board[r][c] == player_id:
                player_subgames += 1
            elif global_board[r][c] == opponent_id:
                opponent_subgames += 1

    total_score += (player_subgames - opponent_subgames) * 200

    # Bonus for controlling the center subgame
    if global_board[1][1] == player_id:
        total_score += 50
    elif global_board[1][1] == opponent_id:
        total_score -= 50
        
    return total_score

def minimax(board, prev_move, depth, alpha, beta, maximizing_player, player_id):
    """Minimax algorithm with Alpha-Beta Pruning."""
    
    global_board = get_global_board_state(board)
    
    # Base case: terminal state or depth limit
    is_game_over = get_subgame_status(global_board) != EMPTY
    if is_game_over or depth == 0:
        return evaluate_board(board, global_board, player_id), None

    valid_moves = get_valid_moves(board, global_board, prev_move)
    if not valid_moves:
        return evaluate_board(board, global_board, player_id), None

    opponent_id = P2 if player_id == P1 else P1
    best_move = random.choice(valid_moves)

    if maximizing_player:
        max_eval = float('-inf')
        for move in valid_moves:
            board_copy = [row[:] for row in board]
            board_copy[move[0]][move[1]] = player_id
            eval, _ = minimax(board_copy, move, depth - 1, alpha, beta, False, player_id)
            if eval > max_eval:
                max_eval = eval
                best_move = move
            alpha = max(alpha, eval)
            if beta <= alpha:
                break
        return max_eval, best_move
    else: # Minimizing player
        min_eval = float('inf')
        for move in valid_moves:
            board_copy = [row[:] for row in board]
            board_copy[move[0]][move[1]] = opponent_id
            eval, _ = minimax(board_copy, move, depth - 1, alpha, beta, True, player_id)
            if eval < min_eval:
                min_eval = eval
                best_move = move
            beta = min(beta, eval)
            if beta <= alpha:
                break
        return min_eval, best_move

# =======================================================
# THE MAIN `play` FUNCTION TO BE CALLED BY THE ENGINE
# =======================================================
def play(board, prev_move, player):
    """
    This is the entry point for your bot.
    board: 9x9 list of lists with 0, 1, or 2.
    prev_move: (r, c) tuple of the last move, or None.
    player: Your player ID, 1 or 2.
    """
    # Strategy: Start in the center if it's the first move.
    if prev_move is None and board[4][4] == EMPTY:
        return (4, 4)

    # Depth 4 is a good balance of strength and speed.
    depth = 4 

    _, best_move = minimax(board, prev_move, depth, float('-inf'), float('inf'), True, player)

    if best_move is None:
        # Fallback if minimax fails (e.g., no valid moves)
        global_board = get_global_board_state(board)
        valid_moves = get_valid_moves(board, global_board, prev_move)
        return random.choice(valid_moves) if valid_moves else (4, 4)

    return best_move